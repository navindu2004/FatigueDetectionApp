//
//  FatigueClassifier.swift
//  FatigueDetector
//
//  Created by Navindu Premaratne on 2025-08-13.
//

import Foundation
import CoreML

class FatigueClassifier {
    
    // The model property can be non-optional now, as we handle errors in the init.
    private let model: FatigueDetector
    
    init() {
        // Use the modern, throwing initializer inside our own initializer.
        // If the model can't be loaded, the app will crash on launch, which is
        // appropriate because the app is unusable without its core model.
        do {
            let configuration = MLModelConfiguration()
            self.model = try FatigueDetector(configuration: configuration)
        } catch {
            fatalError("FATAL ERROR: Failed to load FatigueDetector model: \(error)")
        }
    }
    
    /// Predicts the fatigue state from a dictionary of features.
    func predict(features: [String: Double]) -> FatigueState {
        do {
            // This 'prediction' function is generated by Core ML and can throw an error.
            let prediction = try model.prediction(
                ECG_mean: features["ECG_mean"] ?? 0.0,
                ECG_std: features["ECG_std"] ?? 0.0,
                ECG_max: features["ECG_max"] ?? 0.0,
                ECG_min: features["ECG_min"] ?? 0.0,
                Poz_mean: features["Poz_mean"] ?? 0.0,
                Poz_std: features["Poz_std"] ?? 0.0,
                Poz_max: features["Poz_max"] ?? 0.0,
                Poz_min: features["Poz_min"] ?? 0.0,
                Fz_mean: features["Fz_mean"] ?? 0.0,
                Fz_std: features["Fz_std"] ?? 0.0,
                Fz_max: features["Fz_max"] ?? 0.0,
                Fz_min: features["Fz_min"] ?? 0.0,
                Cz_mean: features["Cz_mean"] ?? 0.0,
                Cz_std: features["Cz_std"] ?? 0.0,
                Cz_max: features["Cz_max"] ?? 0.0,
                Cz_min: features["Cz_min"] ?? 0.0,
                C3_mean: features["C3_mean"] ?? 0.0,
                C3_std: features["C3_std"] ?? 0.0,
                C3_max: features["C3_max"] ?? 0.0,
                C3_min: features["C3_min"] ?? 0.0,
                C4_mean: features["C4_mean"] ?? 0.0,
                C4_std: features["C4_std"] ?? 0.0,
                C4_max: features["C4_max"] ?? 0.0,
                C4_min: features["C4_min"] ?? 0.0,
                F3_mean: features["F3_mean"] ?? 0.0,
                F3_std: features["F3_std"] ?? 0.0,
                F3_max: features["F3_max"] ?? 0.0,
                F3_min: features["F3_min"] ?? 0.0,
                F4_mean: features["F4_mean"] ?? 0.0,
                F4_std: features["F4_std"] ?? 0.0,
                F4_max: features["F4_max"] ?? 0.0,
                F4_min: features["F4_min"] ?? 0.0,
                P3_mean: features["P3_mean"] ?? 0.0,
                P3_std: features["P3_std"] ?? 0.0,
                P3_max: features["P3_max"] ?? 0.0,
                P3_min: features["P3_min"] ?? 0.0,
                P4_mean: features["P4_mean"] ?? 0.0,
                P4_std: features["P4_std"] ?? 0.0,
                P4_max: features["P4_max"] ?? 0.0,
                P4_min: features["P4_min"] ?? 0.0,
                HR_mean: features["HR_mean"] ?? 0.0,
                HR_std: features["HR_std"] ?? 0.0,
                HR_max: features["HR_max"] ?? 0.0,
                HR_min: features["HR_min"] ?? 0.0
            )
            
            // --- THIS IS THE FINAL FIX ---
            // We use the 'target' property that you discovered from the output.
            let predictedLabel = prediction.target
            print("Model predicted label: \(predictedLabel)")
            
            // The output is an Int64. 0 = Awake, 1 = Fatigued.
            return predictedLabel == 1 ? .fatigued : .awake
            
        } catch {
            print("Error: Failed to get a prediction from the model: \(error)")
            // Return a safe default if prediction fails for any reason.
            return .awake
        }
    }
}
